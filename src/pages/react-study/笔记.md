<!--
 * @Author: Jitonghuan 2016670689@qq.com
 * @Date: 2023-02-09 17:00:57
 * @LastEditors: Jitonghuan 2016670689@qq.com
 * @LastEditTime: 2023-02-09 17:02:08
 * @FilePath: /my_umi4_course/src/pages/react-study/笔记.md
 * @Description: 这是默认设置,请设置`customMade`, 打开koroFileHeader查看配置 进行设置: https://github.com/OBKoro1/koro1FileHeader/wiki/%E9%85%8D%E7%BD%AE
-->
1、在组件内部改变state会让组件重新渲染;
2、JSX源码需要工具编译成由若干React.createElement(component,props,...children)函数组成的Js代码，然后才能在浏览器中正常执行；
3、JSX 是JavaScript XML的简称，是react的一个Api,是以上的语法糖；是React组件渲染方法返回值的一部分，react组件里还有其他功能；
4、react是声明式前端框架；（对应函数式编程），命令式编程对应面向对象编程，如java;
5、JSX是声明式的，所以它的内部不应该出现命令式的语句，如if...else,array.forEach,for...of
6、react子元素类型：
子元素的类型包括：
* 字符串，最终会被渲染成 HTML 标签里的字符串；
* 另一段 JSX，会嵌套渲染；
* JS 表达式，会在渲染过程中执行，并让返回值参与到渲染过程中；
* 布尔值、null 值、undefined 值，不会被渲染出来；
* 以上各种类型组成的数组。
**************回字有4种写法*******************

拆分组件原则：
* 单一职责；
* 关注点分离原则；
* 一次且仅一次原则；（DRY ，Don't Repeat Yourself)
* 简约原则

从组件实例层面：组件树是来自运行时的React元素树、从逻辑上排除掉HTML，Fragment等元素，仅保留对应 React 组件的元素节点而形成的精简树。在这棵组件树中，对应元素呈父子关系的一对组件可以称作父子组件。
----------------------------------为什么要关心React组件的渲染机制----------------------

react的UI=f(state),
理论上来说，对于给定的 f() 和状态数据，一定可以重现一模一样的 UI；
这也意味着，只要状态数据有变化，f()就需要重新执行，整个 UI 需要重新渲染。
1、什么是虚拟dom?
React 中虚拟Dom是真实dom的抽象，且远比后者更轻量，是react面向开发者的Api与内部实现对接的桥梁。


2、虚拟dom的好处是什么？
操作真实 DOM 是比较耗费资源的，这时就需要 React 提供一系列算法和过程，过滤掉没有必要的 DOM API 调用，最终把f() 的成本降下来。虚拟 DOM 就是这些算法过程的中间模型，它远比 DOM API 轻量，跟最终的 DOM API 分摊成本后，可以保证 React 组件的渲染效率。
虚拟 DOM 的价值在于，当你构建应用时，无需考虑状态的变化如何体现在 UI 上，且一般情况下不用担心性能问题。这减少了代码 Bug，比起乏味的编码，你可以把更多时间投入到创造性的工作上。

虚拟dom并不是一定就比操作原生dom更快 ，没有任何框架可以比纯手动的优化 DOM 操作更快，因为框架的 DOM 操作层需要应对任何上层 API 可能产生的操作，它的实现必须是普适的。但是我们不可能做的每一步都去优化真实dom操作，会造成很多功夫花在那上面。框架给你的保证是，你在不需要手动优化的情况下，我依然可以给你提供过得去的性能。
举例 例子 ：* 循环2000个随机数组，点击按钮重新生成随机数组渲染页面，也是自己用的js 操作dom 比用react要快*


 
 diff算法核心：
  * 从根元素开始，React 将递归对比两棵树的根元素和子元素；
  * 对比不同类型的元素，如对比 HTML 元素和 React 组件元素，React 会直接清理旧的元素和它的子树，然后建立新的树；
  * 对比同为 HTML 元素，但 Tag 不同的元素，如从 <a> 变成 <div> ，React 会直接清理旧的元素和子树，然后建立新的树；
  * 对比同为 React 组件元素，但组件类或组件函数不同的元素，如从 KanbanNewCard 变成 KanbanCard ，React 会卸载旧的元素和子树，然后挂载新的元素树；
  * 对比 Tag 相同的 HTML 元素，如  <input type="text" value="old" /> 和 <input type="text" value="new" /> ，React 将会保留该元素，并记录有改变的属性，在这个例子里就是 value 的值从 "old" 变成了 "new" ；
  * 对比组件类或组件函数相同的组件元素，如 <KanbanCard title="老卡片" /> 和 <KanbanCard title="新卡片" /> ，React 会保留组件实例，更新 props，并触发组件的生命周期方法或者 Hooks。

*需要强调的是，在对比两棵树对应节点的子元素时，如果子元素形成一个列表，那么 React 会按顺序尝试匹配新旧两个列表的元素。*

如果对比结果是在列表末尾新增或者减少元素那还好，但如果是在列表头部或者中间插入或者删除元素，React 就不知道该保留哪个元素了，干脆把整个列表都推翻了重建，这样会带来性能损耗。
为了应对这种情况，React 引入了 key 这个特殊属性，当有子元素列表中的元素有这个属性时，React 会利用这个 key 属性值来匹配新旧列表中的元素，以减少插入元素时的性能损耗。
这样的用途就要求在任何一个子元素列表中，key 对于每个元素应该是唯一的且稳定的。

3、什么是协调？
React 组件会渲染出一棵元素树。因为开发者使用的是 React 的声明式 API，在此基础上，每次有 props、state 等数据变动时，组件会渲染出新的元素树，React 框架会与之前的树做 Diffing 对比，将元素的变动最终体现在浏览器页面的 DOM 中。这一过程就称为协调（Reconciliation）
4、什么时候会触发协调？
你会选择在什么情况下触发协调？一般而言你会有两个方向的选择，拉（Pull）或者推（Push）。
我们认为，只有数据变化时，才需要触发协调；
props、state，context，这三种数据任何之一发生了变化，都会触发协调；
props和state是不可变的。

5、什么是Fiber 协调引擎？
在react V16之前 协调是一个同步过程，这意味着当虚拟dom足够复杂时，或者元素渲染产生的各种计算足够重，协调过程本身可能超过16ms,严重的会导致页面卡顿。
在react V16之后，协调更改为异步过程，这主要得益于新的Fiber协调引擎，从此在React中更贴近虚拟Dom的，是在Fiber协调引擎中的核心模型 --FiberNode

# 6、什么是纯函数？
* 函数无论被调用多少次，只要参数相同，返回值就一定相同，这一过程不受外部状态或者 IO 操作的影响；
* 函数被调用时不会产生副作用（Side Effect），即不会修改传入的引用参数，不会修改外部状态，不会触发 IO 操作，也不会调用其他会产生副作用的函数。
这样的纯函数组件除了 props、JSX 外，几乎不能使用 React 组件的所有其他特性——对于纯函数组件来说，这些其他特性全部都是外部状态或副作用。

# 7、受控组件？
以 React state 为单一事实来源（Single Source of Truth），并用 React 合成事件处理用户交互的组件，被称为“受控组件”。

# 不要过早做性能优化
强调了开发者在程序开发的早期阶段，有许多重要的工作要做，而优化程序这件事往往会占用了开发者过多的精力，却没能带来对等的收益。
# 遇到性能问题时再优化
# 应用性能问题的表现
1、首次页面加载慢。这个其实在 Web 前端领域是个比较大的话题，浏览器中有一系列指标可以量化页面加载快慢的情况，包括首字节时间（TTFB）、首次内容绘制时间（FCP）、可交互时间（TTI）等，
2、页面局部读取数据慢。这是单页应用的常见设计，比如在页面加载完成后，再延迟加载一个列表数据，这时一般会为列表显示一个临时的“读取中”标识，等到数据到位时再替换成真正的列表内容。有研究表明，加了“读取中”标识的应用比起不加的应用，用户会愿意等待更长的时间。但如果等了 3 秒、5 秒、10 秒列表还没回来，用户会认为这个功能很慢，甚至怀疑哪里出错了。
3、提交表单处理慢。数据下载的反方向是上传，Web 应用一般都是分布式应用，需要提交数据到服务器端进行处理和保存。用户录入表单内容是花费了精力的，提交表单过程慢，更容易导致用户的不安全感。
4、页面跳转慢。这个跟首次页面加载慢类似，电商网站页面跳转慢很容易导致转化率的下降。
5、短时间内多次页面刷新。这是个很微妙但也很普遍的问题，如果用户在应用中完成一系列连贯性的操作，但过程中页面存在多次刷新会打断用户的连续操作时，“慢”的感觉会被放大。

# 解决思路
- 为生产环境构建
- 避免不必要的渲染 / 重新渲染
- 代码分割
如果你构建出来的生产环境产物中，单个 JS 文件有好几个 MB 大小，那可以考虑利用构建工具的代码分割功能，将产物分成多个 chunk，每个 chunk JS 文件几百 KB，可以分摊整体 JS 体积，充分利用浏览器并行下载和缓存的特性优化应用加载速度。





